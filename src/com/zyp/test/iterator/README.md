# 迭代器模式

关于迭代器我们一定不陌生，日常经常使用：
```
Iterator it = list.iterator();
while(it.hasNext()){
    //using “it.next();”do some businesss logic
}
```
定义：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示


迭代器分内部迭代器，外部迭代器，静态迭代器，动态迭代器。

内部迭代器：
> 即迭代器位于容器内部，对外提供迭代方法。优点是不破坏聚集对象的封装。

外部迭代器：
> 迭代器位于容器的外部，仅仅存储一个游标，需要聚集对象想外提供遍历方法，因此会破坏聚集的封装。使用它的重要理由是它可以被几个不同的对象和方法共同享有和控制。


迭代过程中存在一个不变对象的问题，不变对象就是对象在创建后它的内部状态就不在变化，如果在迭代过程中聚集元素发生变化（如增加元素和删除元素）则结果就会不对。


**优缺点**：
优点：

- 迭代器模式简化了聚集的界面，迭代子具备了一个遍历接口，这样聚集的接口就不必具备遍历接口。
- 每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。因此，一个聚集对象可以同时有几个迭代在进行之中。
- 由于遍历算法被封装在迭代器角色里面，因此迭代的算法可以独立于聚集角色变化。由于客户端拿到的是一个迭代器对象，因此，不必知道聚集对象的类型，就可以读取和遍历聚集对象。这样即便聚集对象的类型发生变化，也不会影响到客户端的遍历过程。

缺点：

- 迭代器模式给客户端一个聚集被顺序化的错觉，因为大多数的情况下聚集的元素并没有确定的顺序，但是迭代必须以一定线性顺序进行。如果客户端误以为顺序是聚集本身具有的特性而过度依赖于聚集元素的顺序，很可能得出错误的结果。
- 迭代器给出的聚集元素没有类型特征，一般而言，迭代器给出的元素都是boject类型，因此，客户端必须具备这些元素类型的知识才能使用这些元素。

**迭代器模式的适用范围**:

- 访问一个容器对象的内容而无需暴露它的内部表示。
- 支持对容器对象的多种遍历。
- 为遍历不同的容器结构提供一个统一的接口(多态迭代)。
